//
// Autogenerated by Thrift Compiler (1.0.0-dev)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var thrift = require('woody_js/src/client/gen');
var Thrift = thrift.Thrift;
var Q = thrift.Q;

var domain_ttypes = require('./domain_types');


var ttypes = module.exports = {};
var Head = module.exports.Head = function(args) {
};
Head.prototype = {};
Head.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Head.prototype.write = function(output) {
  output.writeStructBegin('Head');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Reference = module.exports.Reference = function(args) {
  this.version = null;
  this.head = null;
  if (args) {
    if (args.version !== undefined && args.version !== null) {
      this.version = args.version;
    }
    if (args.head !== undefined && args.head !== null) {
      this.head = new ttypes.Head(args.head);
    }
  }
};
Reference.prototype = {};
Reference.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.version = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.head = new ttypes.Head();
        this.head.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Reference.prototype.write = function(output) {
  output.writeStructBegin('Reference');
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.I64, 1);
    output.writeI64(this.version);
    output.writeFieldEnd();
  }
  if (this.head !== null && this.head !== undefined) {
    output.writeFieldBegin('head', Thrift.Type.STRUCT, 2);
    this.head.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Snapshot = module.exports.Snapshot = function(args) {
  this.version = null;
  this.domain = null;
  if (args) {
    if (args.version !== undefined && args.version !== null) {
      this.version = args.version;
    }
    if (args.domain !== undefined && args.domain !== null) {
      this.domain = Thrift.copyMap(args.domain, [domain_ttypes.DomainObject]);
    }
  }
};
Snapshot.prototype = {};
Snapshot.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.version = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.MAP) {
        var _size0 = 0;
        var _rtmp34;
        this.domain = new Map();
        var _ktype1 = 0;
        var _vtype2 = 0;
        _rtmp34 = input.readMapBegin();
        _ktype1 = _rtmp34.ktype;
        _vtype2 = _rtmp34.vtype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          var key6 = null;
          var val7 = null;
          key6 = new domain_ttypes.Reference();
          key6.read(input);
          val7 = new domain_ttypes.DomainObject();
          val7.read(input);
          this.domain.set(key6, val7);
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Snapshot.prototype.write = function(output) {
  output.writeStructBegin('Snapshot');
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.I64, 1);
    output.writeI64(this.version);
    output.writeFieldEnd();
  }
  if (this.domain !== null && this.domain !== undefined) {
    output.writeFieldBegin('domain', Thrift.Type.MAP, 2);
    output.writeMapBegin(Thrift.Type.STRUCT, Thrift.Type.STRUCT, this.domain.size);
    var func10 = function(viter9, kiter8) {
      kiter8.write(output);
      viter9.write(output);
    };
    this.domain.forEach(func10);
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Commit = module.exports.Commit = function(args) {
  this.ops = null;
  if (args) {
    if (args.ops !== undefined && args.ops !== null) {
      this.ops = Thrift.copyList(args.ops, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ops is unset!');
    }
  }
};
Commit.prototype = {};
Commit.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size11 = 0;
        var _rtmp315;
        this.ops = [];
        var _etype14 = 0;
        _rtmp315 = input.readListBegin();
        _etype14 = _rtmp315.etype;
        _size11 = _rtmp315.size;
        for (var _i16 = 0; _i16 < _size11; ++_i16)
        {
          var elem17 = null;
          elem17 = new ttypes.Operation();
          elem17.read(input);
          this.ops.push(elem17);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Commit.prototype.write = function(output) {
  output.writeStructBegin('Commit');
  if (this.ops !== null && this.ops !== undefined) {
    output.writeFieldBegin('ops', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.ops.length);
    for (var iter18 in this.ops)
    {
      if (this.ops.hasOwnProperty(iter18))
      {
        iter18 = this.ops[iter18];
        iter18.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Operation = module.exports.Operation = function(args) {
  this.insert = null;
  this.update = null;
  this.remove = null;
  if (args) {
    if (args.insert !== undefined && args.insert !== null) {
      this.insert = new ttypes.InsertOp(args.insert);
    }
    if (args.update !== undefined && args.update !== null) {
      this.update = new ttypes.UpdateOp(args.update);
    }
    if (args.remove !== undefined && args.remove !== null) {
      this.remove = new ttypes.RemoveOp(args.remove);
    }
  }
};
Operation.prototype = {};
Operation.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.insert = new ttypes.InsertOp();
        this.insert.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.update = new ttypes.UpdateOp();
        this.update.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.remove = new ttypes.RemoveOp();
        this.remove.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Operation.prototype.write = function(output) {
  output.writeStructBegin('Operation');
  if (this.insert !== null && this.insert !== undefined) {
    output.writeFieldBegin('insert', Thrift.Type.STRUCT, 1);
    this.insert.write(output);
    output.writeFieldEnd();
  }
  if (this.update !== null && this.update !== undefined) {
    output.writeFieldBegin('update', Thrift.Type.STRUCT, 2);
    this.update.write(output);
    output.writeFieldEnd();
  }
  if (this.remove !== null && this.remove !== undefined) {
    output.writeFieldBegin('remove', Thrift.Type.STRUCT, 3);
    this.remove.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var InsertOp = module.exports.InsertOp = function(args) {
  this.object = null;
  if (args) {
    if (args.object !== undefined && args.object !== null) {
      this.object = new domain_ttypes.DomainObject(args.object);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field object is unset!');
    }
  }
};
InsertOp.prototype = {};
InsertOp.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.object = new domain_ttypes.DomainObject();
        this.object.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

InsertOp.prototype.write = function(output) {
  output.writeStructBegin('InsertOp');
  if (this.object !== null && this.object !== undefined) {
    output.writeFieldBegin('object', Thrift.Type.STRUCT, 1);
    this.object.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var UpdateOp = module.exports.UpdateOp = function(args) {
  this.old_object = null;
  this.new_object = null;
  if (args) {
    if (args.old_object !== undefined && args.old_object !== null) {
      this.old_object = new domain_ttypes.DomainObject(args.old_object);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field old_object is unset!');
    }
    if (args.new_object !== undefined && args.new_object !== null) {
      this.new_object = new domain_ttypes.DomainObject(args.new_object);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field new_object is unset!');
    }
  }
};
UpdateOp.prototype = {};
UpdateOp.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.old_object = new domain_ttypes.DomainObject();
        this.old_object.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.new_object = new domain_ttypes.DomainObject();
        this.new_object.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

UpdateOp.prototype.write = function(output) {
  output.writeStructBegin('UpdateOp');
  if (this.old_object !== null && this.old_object !== undefined) {
    output.writeFieldBegin('old_object', Thrift.Type.STRUCT, 1);
    this.old_object.write(output);
    output.writeFieldEnd();
  }
  if (this.new_object !== null && this.new_object !== undefined) {
    output.writeFieldBegin('new_object', Thrift.Type.STRUCT, 2);
    this.new_object.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var RemoveOp = module.exports.RemoveOp = function(args) {
  this.object = null;
  if (args) {
    if (args.object !== undefined && args.object !== null) {
      this.object = new domain_ttypes.DomainObject(args.object);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field object is unset!');
    }
  }
};
RemoveOp.prototype = {};
RemoveOp.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.object = new domain_ttypes.DomainObject();
        this.object.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

RemoveOp.prototype.write = function(output) {
  output.writeStructBegin('RemoveOp');
  if (this.object !== null && this.object !== undefined) {
    output.writeFieldBegin('object', Thrift.Type.STRUCT, 1);
    this.object.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var VersionedObject = module.exports.VersionedObject = function(args) {
  this.version = null;
  this.object = null;
  if (args) {
    if (args.version !== undefined && args.version !== null) {
      this.version = args.version;
    }
    if (args.object !== undefined && args.object !== null) {
      this.object = new domain_ttypes.DomainObject(args.object);
    }
  }
};
VersionedObject.prototype = {};
VersionedObject.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.version = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.object = new domain_ttypes.DomainObject();
        this.object.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

VersionedObject.prototype.write = function(output) {
  output.writeStructBegin('VersionedObject');
  if (this.version !== null && this.version !== undefined) {
    output.writeFieldBegin('version', Thrift.Type.I64, 1);
    output.writeI64(this.version);
    output.writeFieldEnd();
  }
  if (this.object !== null && this.object !== undefined) {
    output.writeFieldBegin('object', Thrift.Type.STRUCT, 2);
    this.object.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var VersionNotFound = module.exports.VersionNotFound = function(args) {
  Thrift.TException.call(this, "VersionNotFound")
  this.name = "VersionNotFound"
};
Thrift.inherits(VersionNotFound, Thrift.TException);
VersionNotFound.prototype.name = 'VersionNotFound';
VersionNotFound.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

VersionNotFound.prototype.write = function(output) {
  output.writeStructBegin('VersionNotFound');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ObjectNotFound = module.exports.ObjectNotFound = function(args) {
  Thrift.TException.call(this, "ObjectNotFound")
  this.name = "ObjectNotFound"
};
Thrift.inherits(ObjectNotFound, Thrift.TException);
ObjectNotFound.prototype.name = 'ObjectNotFound';
ObjectNotFound.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ObjectNotFound.prototype.write = function(output) {
  output.writeStructBegin('ObjectNotFound');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var OperationConflict = module.exports.OperationConflict = function(args) {
  Thrift.TException.call(this, "OperationConflict")
  this.name = "OperationConflict"
  this.conflict = null;
  if (args) {
    if (args.conflict !== undefined && args.conflict !== null) {
      this.conflict = new ttypes.Conflict(args.conflict);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field conflict is unset!');
    }
  }
};
Thrift.inherits(OperationConflict, Thrift.TException);
OperationConflict.prototype.name = 'OperationConflict';
OperationConflict.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.conflict = new ttypes.Conflict();
        this.conflict.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

OperationConflict.prototype.write = function(output) {
  output.writeStructBegin('OperationConflict');
  if (this.conflict !== null && this.conflict !== undefined) {
    output.writeFieldBegin('conflict', Thrift.Type.STRUCT, 1);
    this.conflict.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Conflict = module.exports.Conflict = function(args) {
  this.object_already_exists = null;
  this.object_not_found = null;
  this.object_reference_mismatch = null;
  this.objects_not_exist = null;
  if (args) {
    if (args.object_already_exists !== undefined && args.object_already_exists !== null) {
      this.object_already_exists = new ttypes.ObjectAlreadyExistsConflict(args.object_already_exists);
    }
    if (args.object_not_found !== undefined && args.object_not_found !== null) {
      this.object_not_found = new ttypes.ObjectNotFoundConflict(args.object_not_found);
    }
    if (args.object_reference_mismatch !== undefined && args.object_reference_mismatch !== null) {
      this.object_reference_mismatch = new ttypes.ObjectReferenceMismatchConflict(args.object_reference_mismatch);
    }
    if (args.objects_not_exist !== undefined && args.objects_not_exist !== null) {
      this.objects_not_exist = new ttypes.ObjectsNotExistConflict(args.objects_not_exist);
    }
  }
};
Conflict.prototype = {};
Conflict.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.object_already_exists = new ttypes.ObjectAlreadyExistsConflict();
        this.object_already_exists.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.object_not_found = new ttypes.ObjectNotFoundConflict();
        this.object_not_found.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.object_reference_mismatch = new ttypes.ObjectReferenceMismatchConflict();
        this.object_reference_mismatch.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.objects_not_exist = new ttypes.ObjectsNotExistConflict();
        this.objects_not_exist.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Conflict.prototype.write = function(output) {
  output.writeStructBegin('Conflict');
  if (this.object_already_exists !== null && this.object_already_exists !== undefined) {
    output.writeFieldBegin('object_already_exists', Thrift.Type.STRUCT, 1);
    this.object_already_exists.write(output);
    output.writeFieldEnd();
  }
  if (this.object_not_found !== null && this.object_not_found !== undefined) {
    output.writeFieldBegin('object_not_found', Thrift.Type.STRUCT, 2);
    this.object_not_found.write(output);
    output.writeFieldEnd();
  }
  if (this.object_reference_mismatch !== null && this.object_reference_mismatch !== undefined) {
    output.writeFieldBegin('object_reference_mismatch', Thrift.Type.STRUCT, 3);
    this.object_reference_mismatch.write(output);
    output.writeFieldEnd();
  }
  if (this.objects_not_exist !== null && this.objects_not_exist !== undefined) {
    output.writeFieldBegin('objects_not_exist', Thrift.Type.STRUCT, 4);
    this.objects_not_exist.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ObjectAlreadyExistsConflict = module.exports.ObjectAlreadyExistsConflict = function(args) {
  this.object_ref = null;
  if (args) {
    if (args.object_ref !== undefined && args.object_ref !== null) {
      this.object_ref = new domain_ttypes.Reference(args.object_ref);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field object_ref is unset!');
    }
  }
};
ObjectAlreadyExistsConflict.prototype = {};
ObjectAlreadyExistsConflict.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.object_ref = new domain_ttypes.Reference();
        this.object_ref.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ObjectAlreadyExistsConflict.prototype.write = function(output) {
  output.writeStructBegin('ObjectAlreadyExistsConflict');
  if (this.object_ref !== null && this.object_ref !== undefined) {
    output.writeFieldBegin('object_ref', Thrift.Type.STRUCT, 1);
    this.object_ref.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ObjectNotFoundConflict = module.exports.ObjectNotFoundConflict = function(args) {
  this.object_ref = null;
  if (args) {
    if (args.object_ref !== undefined && args.object_ref !== null) {
      this.object_ref = new domain_ttypes.Reference(args.object_ref);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field object_ref is unset!');
    }
  }
};
ObjectNotFoundConflict.prototype = {};
ObjectNotFoundConflict.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.object_ref = new domain_ttypes.Reference();
        this.object_ref.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ObjectNotFoundConflict.prototype.write = function(output) {
  output.writeStructBegin('ObjectNotFoundConflict');
  if (this.object_ref !== null && this.object_ref !== undefined) {
    output.writeFieldBegin('object_ref', Thrift.Type.STRUCT, 1);
    this.object_ref.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ObjectReferenceMismatchConflict = module.exports.ObjectReferenceMismatchConflict = function(args) {
  this.object_ref = null;
  if (args) {
    if (args.object_ref !== undefined && args.object_ref !== null) {
      this.object_ref = new domain_ttypes.Reference(args.object_ref);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field object_ref is unset!');
    }
  }
};
ObjectReferenceMismatchConflict.prototype = {};
ObjectReferenceMismatchConflict.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.object_ref = new domain_ttypes.Reference();
        this.object_ref.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ObjectReferenceMismatchConflict.prototype.write = function(output) {
  output.writeStructBegin('ObjectReferenceMismatchConflict');
  if (this.object_ref !== null && this.object_ref !== undefined) {
    output.writeFieldBegin('object_ref', Thrift.Type.STRUCT, 1);
    this.object_ref.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ObjectsNotExistConflict = module.exports.ObjectsNotExistConflict = function(args) {
  this.object_refs = null;
  if (args) {
    if (args.object_refs !== undefined && args.object_refs !== null) {
      this.object_refs = Thrift.copyList(args.object_refs, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field object_refs is unset!');
    }
  }
};
ObjectsNotExistConflict.prototype = {};
ObjectsNotExistConflict.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size19 = 0;
        var _rtmp323;
        this.object_refs = [];
        var _etype22 = 0;
        _rtmp323 = input.readListBegin();
        _etype22 = _rtmp323.etype;
        _size19 = _rtmp323.size;
        for (var _i24 = 0; _i24 < _size19; ++_i24)
        {
          var elem25 = null;
          elem25 = new ttypes.NonexistantObject();
          elem25.read(input);
          this.object_refs.push(elem25);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ObjectsNotExistConflict.prototype.write = function(output) {
  output.writeStructBegin('ObjectsNotExistConflict');
  if (this.object_refs !== null && this.object_refs !== undefined) {
    output.writeFieldBegin('object_refs', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.object_refs.length);
    for (var iter26 in this.object_refs)
    {
      if (this.object_refs.hasOwnProperty(iter26))
      {
        iter26 = this.object_refs[iter26];
        iter26.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var NonexistantObject = module.exports.NonexistantObject = function(args) {
  this.object_ref = null;
  this.referenced_by = null;
  if (args) {
    if (args.object_ref !== undefined && args.object_ref !== null) {
      this.object_ref = new domain_ttypes.Reference(args.object_ref);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field object_ref is unset!');
    }
    if (args.referenced_by !== undefined && args.referenced_by !== null) {
      this.referenced_by = Thrift.copyList(args.referenced_by, [domain_ttypes.Reference]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field referenced_by is unset!');
    }
  }
};
NonexistantObject.prototype = {};
NonexistantObject.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.object_ref = new domain_ttypes.Reference();
        this.object_ref.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size27 = 0;
        var _rtmp331;
        this.referenced_by = [];
        var _etype30 = 0;
        _rtmp331 = input.readListBegin();
        _etype30 = _rtmp331.etype;
        _size27 = _rtmp331.size;
        for (var _i32 = 0; _i32 < _size27; ++_i32)
        {
          var elem33 = null;
          elem33 = new domain_ttypes.Reference();
          elem33.read(input);
          this.referenced_by.push(elem33);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

NonexistantObject.prototype.write = function(output) {
  output.writeStructBegin('NonexistantObject');
  if (this.object_ref !== null && this.object_ref !== undefined) {
    output.writeFieldBegin('object_ref', Thrift.Type.STRUCT, 1);
    this.object_ref.write(output);
    output.writeFieldEnd();
  }
  if (this.referenced_by !== null && this.referenced_by !== undefined) {
    output.writeFieldBegin('referenced_by', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.referenced_by.length);
    for (var iter34 in this.referenced_by)
    {
      if (this.referenced_by.hasOwnProperty(iter34))
      {
        iter34 = this.referenced_by[iter34];
        iter34.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var ObsoleteCommitVersion = module.exports.ObsoleteCommitVersion = function(args) {
  Thrift.TException.call(this, "ObsoleteCommitVersion")
  this.name = "ObsoleteCommitVersion"
};
Thrift.inherits(ObsoleteCommitVersion, Thrift.TException);
ObsoleteCommitVersion.prototype.name = 'ObsoleteCommitVersion';
ObsoleteCommitVersion.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ObsoleteCommitVersion.prototype.write = function(output) {
  output.writeStructBegin('ObsoleteCommitVersion');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

